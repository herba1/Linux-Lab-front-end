<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Article with Intersection Observer Navigation</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 0;
    }
    
    .container {
      display: flex;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    main {
      flex: 3;
      padding-right: 40px;
    }
    
    aside {
      flex: 1;
    }
    
    nav {
      position: sticky;
      top: 20px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    
    nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    nav li {
      margin-bottom: 10px;
    }
    
    nav a {
      text-decoration: none;
      color: #333;
      display: block;
      padding: 5px 10px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    
    nav a.active {
      background-color: #0077cc;
      color: white;
      font-weight: bold;
    }
    
    section {
      min-height: 80vh;
      margin-bottom: 40px;
      padding: 20px;
      border-radius: 8px;
      background-color: #f8f9fa;
    }
    
    /* Visual indicator for debugging */
    .observer-line {
      position: fixed;
      left: 0;
      top: 30%;
      width: 100%;
      height: 2px;
      background-color: red;
      z-index: 100;
      pointer-events: none;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <!-- Visual indicator showing where our observer is watching -->
  <div class="observer-line"></div>

  <div class="container">
    <main>
      <h1>Understanding the Intersection Observer API</h1>
      
      <section id="introduction">
        <h2>Introduction</h2>
        <p>The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport.</p>
        <p>This is extremely useful for implementing features like:</p>
        <ul>
          <li>Lazy-loading of images or other content as a page is scrolled</li>
          <li>Implementing "infinite scrolling" web sites</li>
          <li>Reporting of visibility of advertisements in order to calculate ad revenue</li>
          <li>Deciding whether or not to perform tasks or animation processes based on whether or not the user will see the result</li>
        </ul>
      </section>
      
      <section id="how-it-works">
        <h2>How It Works</h2>
        <p>The Intersection Observer API lets you configure a callback that is called when either of these circumstances occur:</p>
        <ul>
          <li>A target element intersects either the device's viewport or a specified element (called the root)</li>
          <li>The first time the observer is initially asked to watch a target element</li>
        </ul>
        <p>Unlike event-based solutions that constantly check positions on scroll events, Intersection Observers are more efficient as they operate asynchronously.</p>
      </section>
      
      <section id="creating-observer">
        <h2>Creating an Observer</h2>
        <p>Creating an Intersection Observer is straightforward. You call its constructor and pass it a callback function and an options object:</p>
        <pre><code>
const options = {
  root: null, // use the viewport
  rootMargin: '0px',
  threshold: 0.5 // trigger when 50% of the element is visible
};

const observer = new IntersectionObserver(callback, options);

// Start observing an element
observer.observe(targetElement);
        </code></pre>
      </section>
      
      <section id="callback-function">
        <h2>The Callback Function</h2>
        <p>When an observed element crosses the specified threshold, your callback function is invoked with a list of IntersectionObserverEntry objects:</p>
        <pre><code>
function callback(entries, observer) {
  entries.forEach(entry => {
    // Each entry describes an intersection change for one observed target element
    if (entry.isIntersecting) {
      console.log(`${entry.target.id} is now visible`);
      // Do something with the visible element
    } else {
      console.log(`${entry.target.id} is no longer visible`);
      // Handle the element leaving the viewport
    }
  });
}
        </code></pre>
      </section>
      
      <section id="threshold">
        <h2>Understanding Thresholds</h2>
        <p>The threshold option tells the observer at what percentage of the target's visibility the callback should be executed:</p>
        <ul>
          <li>0 (default) - Callback is invoked as soon as even one pixel is visible</li>
          <li>1.0 - Callback is invoked when 100% of the target is visible</li>
          <li>Array of values - Callback is invoked at each threshold crossed in either direction</li>
        </ul>
        <p>For example, [0, 0.25, 0.5, 0.75, 1] would trigger the callback when the element is 0%, 25%, 50%, 75%, and 100% visible.</p>
      </section>
      
      <section id="root-margin">
        <h2>Root Margin</h2>
        <p>The rootMargin option allows you to expand or shrink the effective size of the root element's bounding box before computing intersections:</p>
        <pre><code>
// Margin syntax works like CSS margins: top, right, bottom, left
rootMargin: '100px 0px 0px 0px'
        </code></pre>
        <p>This is particularly useful for triggering content loading before an element actually becomes visible, providing a smoother user experience.</p>
      </section>
    </main>
    
    <aside>
      <nav>
        <h3>Table of Contents</h3>
        <ul id="nav-links">
          <li><a href="#introduction">Introduction</a></li>
          <li><a href="#how-it-works">How It Works</a></li>
          <li><a href="#creating-observer">Creating an Observer</a></li>
          <li><a href="#callback-function">The Callback Function</a></li>
          <li><a href="#threshold">Understanding Thresholds</a></li>
          <li><a href="#root-margin">Root Margin</a></li>
        </ul>
      </nav>
    </aside>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Get all the sections we want to observe
      const sections = document.querySelectorAll('section');
      
      // Get all navigation links
      const navLinks = document.querySelectorAll('#nav-links a');
      
      // This function updates the active state in the navigation
      function updateActiveNavLink(currentSectionId) {
        navLinks.forEach(link => {
          // Get the section ID this link points to
          const sectionId = link.getAttribute('href').substring(1);
          
          // If this link's section is the current one, make it active
          if (sectionId === currentSectionId) {
            link.classList.add('active');
          } else {
            link.classList.remove('active');
          }
        });
      }
      
      // Setup the intersection observer
      // This is where you tell the computer: "Hey, when an element crosses this line, notify me!"
      const observerOptions = {
        // null means use the viewport as the container
        root: null,
        // This creates a line at 30% from the top of the viewport (matching our visual indicator)
        rootMargin: '-50% 0px -50% 0px',
        // Trigger when any part of the element is visible (you can adjust this)
        threshold: 0
      };
      
      // Create the observer with our callback
      const observer = new IntersectionObserver((entries) => {
        // This function runs whenever an observed element crosses our line
        entries.forEach(entry => {
          // Get the ID of the section that just crossed the line
          const id = entry.target.getAttribute('id');
          
          // If the section is intersecting (crossing into view)
          if (entry.isIntersecting) {
            console.log(`Section "${id}" is now at our observer line`);
            updateActiveNavLink(id);
          }
        });
      }, observerOptions);
      
      // Start observing all sections
      sections.forEach(section => {
        observer.observe(section);
      });
      
      // Initialize navigation with the first section active
      updateActiveNavLink('introduction');
    });
  </script>
</body>
</html>